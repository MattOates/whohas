#!/usr/bin/perl

# whohas, a Perl utility to display availability of source
# and binary packages from major Linux and BSD distributions
#
# Copyright (C) Philipp L. Wesche 2005
#
#
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA

use strict;
use sigtrap;

my $archbase   = "http://www.archlinux.org";
my $aurbase    = "http://aur.archlinux.org";
my $debianbase = "http://packages.debian.org";
my $gentoobase = "http://packages.gentoo.org";
my $fedorabase = "http://download.fedora.redhat.com/pub/fedora/linux";
my $netbsdbase = "ftp://ftp.netbsd.org/pub/NetBSD/packages/pkgsrc/";


use Env qw(HOME);
use threads;

my $confdir = "$HOME/.whohas";
# make .whohas directory in home directory
unless (-d $confdir) {
	mkdir ($confdir, 0777);
}

my @columns = (9,25,10,4,10,11);
my $cols = 6;

my @thrs;
my $here = 0;
if (@ARGV == 1) {
	$thrs[$here++] = threads->new(\&arch,        $ARGV[0]);
	$thrs[$here++] = threads->new(\&aur,         $ARGV[0]);
	$thrs[$here++] = threads->new(\&debian,      $ARGV[0]);
	$thrs[$here++] = threads->new(\&fedora_wget, $ARGV[0]);
	$thrs[$here++] = threads->new(\&freebsd,     $ARGV[0]);
	$thrs[$here++] = threads->new(\&gentoo,      $ARGV[0]);
	$thrs[$here++] = threads->new(\&netbsd,      $ARGV[0]);
	$thrs[$here++] = threads->new(\&openbsd,     $ARGV[0]);
	$thrs[$here++] = threads->new(\&slack,       $ARGV[0]);
	$thrs[$here++] = threads->new(\&sm,          $ARGV[0]);
	foreach (@thrs) {
		$_->join;
	}
} else {
	die "Too many parameters. Usage: $0 pkgname\n";
}



sub fedora_write {
	my $file = $_[1];
	my $arch = $_[2];
	my @names;
	my @versions;
	my @dates;
	my @sizes;
	my @repos;
	
	my $baseurl = "ftp://download.fedora.redhat.com/pub/fedora/linux";
	my $tempfile = "$file.tmp";
	
	if (-s $file && ($_[3]==0 || `date -Idate` =~ (split / /, `ls -l $file`)[6])) {
		# read in
		open IN, $file;
		chomp (my @inlines = <IN>);
		close IN;
		foreach (@inlines) {
			my @parts = split /\t/,$_;
			push @names,    $parts[0];
			push @versions, $parts[1];
			push @dates,    $parts[2];
			push @sizes,    $parts[3];
		}
	} else {
		#download
		system "wget -q $baseurl".$_[0]." -O $tempfile";
		open IN, "$tempfile";
		chomp (my @lines = <IN>);
		close IN;
		system "rm $tempfile";
		my $here = 0;
		for (my $i = 0; $i < @lines; $i++) {
			if ($lines[$i] =~ /^  200/) {
				($names[$here],$versions[$here],$dates[$here],$sizes[$here]) = &fedora_analyse($lines[$i],$arch);
				$here++;
			}
		}
		open OUT, ">$file";
		for (my $a = 0; $a < @names; $a++) {
			print OUT "$names[$a]\t$versions[$a]\t$dates[$a]\t$sizes[$a]\n";
		}
		close OUT;
	}
	foreach (@names) {
		push @repos, $_[4];
	}
	return(\@names,\@versions,\@dates,\@sizes,\@repos);
}

sub fedora_analyse {
	my $arch = $_[1];
	my $size = (split /\(|\)/, $_[0])[1];
	$size =~ s/ bytes$//;
	$size =~ s/,//g;
	my $date = join " ", reverse ((split / +/, $_[0])[1..3]);
	chomp ($date = `date -d \"$date\" -Idate`);
	my $nad = (split /">|\.rpm/, $_[0])[2];
	$nad =~ s/\.$arch//g;
	my ($name,$version) = &combos($nad);
	return ($name,$version,$date,$size);
}

sub fedora_wget {
	my $current_release = 4;
	my $distroname = "fc";
	my $arch = "i386";
	my @ininames;
	my @iniversions;
	my @inidates;
	my @inisizes;
	my @inirepos;
	for (my $i = 4; $i <= $current_release; $i++) { # just the one release for now
		my @fed_repos = ("core","updates","extras");
		my @fed_updates = (0,1,1); #whether to ask for an update or not
		my @fed_urls = ("/core/$i/i386/os/Fedora/RPMS/","/core/updates/$i/$arch/","/extras/$i/$arch/");
		for (my $a = 0; $a < @fed_repos; $a++) {
			my $file = "$confdir/$distroname.$i.".$fed_repos[$a].".list";
			my ($p1,$p2,$p3,$p4,$p5) = &fedora_write($fed_urls[$a],$file,$arch,$fed_updates[$a],$fed_repos[$a]);
			push @ininames,    @$p1;
			push @iniversions, @$p2;
			push @inidates,    @$p3;
			push @inisizes,    @$p4;
			push @inirepos,    @$p5;
		}
	}
	my @names;
	my @repos;
	my @sizes;
	my @versions;
	my @dates;
	my @urls;
	for (my $i = 0; $i < @ininames;$i++) {
		my $mustmatch = $_[0];
		if ($ininames[$i] =~ /$mustmatch/) {
			push @names,    $ininames[$i];
			push @repos,    $inirepos[$i];
			push @dates,    $inidates[$i];
			push @versions, $iniversions[$i];
			push @sizes,    $inisizes[$i];
			push @urls, "";
		}
		# remove all that are the same
		for (my $i = 0; $i < @names; $i++) {
			for (my $a = $i + 1; $a < @names; $a++) {
				if ($names[$i] eq $names[$a]) {
					splice (@names,    $i, 1);
					splice (@versions, $i, 1);
					splice (@dates,    $i, 1);
					splice (@sizes,    $i, 1);
					splice (@repos,    $i, 1);
					splice (@urls,     $i, 1);
				}
			}
		}
	}
	for (my $i = 0; $i < @repos; $i++) {
		&pretty_print($cols,@columns,"Fedora",$names[$i],$versions[$i],
			&size_trim($sizes[$i]),
		$dates[$i],$repos[$i],$urls[$i]);
	}
	return ();
}

sub size_trim {
	# give at least two significant figures; if a 10^3 edge is encountered, put a dot
	my $leave =  length($_[0]) % 3;
	my $threes = (length($_[0]) - $leave) / 3;
	if ($leave == 0) {
		$leave = 3;
		$threes--;
	}
	
	my @parts = split //, $_[0];
	my $retval = join "", @parts[0..($leave-1)];
	if (length($retval)==1 && $threes > 0) {
		# add one more significant figure
		my $add_sf = $parts[$leave];
		if ($parts[$leave+1] > 4) {
			# rounding
			$add_sf++;
			if ($add_sf == 10) {
				$add_sf = 0;
				$retval++;
				if ($retval == 10) {
					return(&size_trim($retval*(1000**$threes)));
				}
			}
		}
		$retval .= ".$add_sf";
	} elsif (defined($parts[$leave]) && $parts[$leave] > 4) { # instead of defined(...), ($threes > 0) is also possible
		my $before = length($retval);
		# rounding
		$retval++;
		if (length($retval) > $before) {
			return(&size_trim($retval*(1000**$threes)));
		}
	}
	my @suffixes = ("k","M","G");
	if ($threes > 0) {
		$retval .= $suffixes[($threes-1)];
	}
	return $retval;
}


sub freebsd {
	my $query = "http://www.freebsd.org/cgi/ports.cgi?query=".$_[0]."&stype=all";
	my @lines = split /\n/, &fetchdoc($query);
	my @names;
	my @versions;
	my @dates;
	my @sizes;
	my @repos;
	my @urls;
	my $now = 0;
	for (my $i = 50; $i<@lines; $i++) {
		if ($lines[$i] =~ /^<DT><B>/) {
			my $anchor = (split /"/, $lines[$i])[1];
			($names[$now],$versions[$now]) = &combos($anchor);
			$now++;
			push @repos, "";
			push @sizes, "";
			push @urls,  "$query#$anchor";
			push @dates, "";
		}
	}
	for (my $i = 0; $i < @repos; $i++) {
		&pretty_print($cols,@columns,"FreeBSD",$names[$i],$versions[$i],$sizes[$i],$dates[$i],$repos[$i],$urls[$i]);
	}
	return ();
}

sub combos {
	my @chars = split //, $_[0];
	my $name;
	my $version;
	for (my $i = 0; $i < @chars-1; $i++) {
		if ($chars[$i] eq "-" && $chars[$i+1] =~ /[0-9]/) {
			$name = join "", @chars[0..($i-1)];
			$version = join "", @chars[($i+1)..(@chars-1)];
			last;
		}
	}
	return($name,$version);
}


sub sm {
	my @grimoires = ("test","stable","games","z-rejected");
	my @lines = split /\n/, &fetchdoc("http://codex.sourcemage.org/listing.txt");
	my @inirepos;
	my @ininames;
	my @iniversions;
	my @iniurls;
	my @inidates;
	my @inisizes;
	foreach (@lines) {
		my @comps = split /\^/, $_;
		for (my $a = 0; $a < @grimoires;$a++) {
			if (length($comps[$a+1]) > 0) {
				push @inirepos, $grimoires[$a];
				push @ininames, $comps[0];
				push @iniversions, $comps[$a+1];
				push @inisizes, "";
				push @iniurls,  "";
				push @inidates, "";
			}
		}
	}
	my ($p1,$p2,$p3,$p4,$p5,$p6) = &search_by_name(\@ininames,\@iniversions,\@inisizes,\@inidates,\@inirepos,\@iniurls,$_[0]);
	my @names    = @$p1;
	my @versions = @$p2;
	my @sizes    = @$p3;
	my @dates    = @$p4;
	my @repos    = @$p5;
	my @urls     = @$p6;
	for (my $i = 0; $i < @repos; $i++) {
		&pretty_print($cols,@columns,"SMGL",$names[$i],$versions[$i],$sizes[$i],$dates[$i],$repos[$i],$urls[$i]);
	}
	return ();
}


sub search_by_name { # versions, sizes, dates, repos, urls
	my ($p1,$p2,$p3,$p4,$p5,$p6,$search) = @_;
	my @ininames    = @$p1;
	my @iniversions = @$p2;
	my @inisizes    = @$p3;
	my @inidates    = @$p4;
	my @inirepos    = @$p5;
	my @iniurls     = @$p6;
	my @names;
	my @versions;
	my @sizes;
	my @dates;
	my @repos;
	my @urls;
	for (my $i = 0;$i<@ininames;$i++) {
		if ($ininames[$i] =~ /$search/i) {
			push @names,    $ininames[$i];
			push @repos,    $inirepos[$i];
			push @versions, $iniversions[$i];
			push @sizes,    $inisizes[$i];
			push @dates,    $inidates[$i];
			push @urls,     $iniurls[$i];
		}
	}
	return(\@names,\@versions,\@sizes,\@dates,\@repos,\@urls)
}
sub netbsd {
	my @ininames;
	my @iniversions;
	my @iniurls;
	my @inirepos;
	my @inisizes;
	my @inidates;
	my $now = 0;
	my $distroname = "NetBSD";
	my $file = "$confdir/$distroname.list";
	# if the list file exists and is recent, use its contents, otherwise download and parse a fresh copy
	if (-s $file && `date -Idate` =~ (split / /, `ls -l $file`)[6]) {
		open IN, $file;
		chomp (my @lines = <IN>);
		for (my $i = 0; $i<@lines;$i++) {
			($ininames[$i],$iniversions[$i],$iniurls[$i]) = split /\t/, $lines[$i];
		}
		close IN;
	} else {
		my @lines = split /\n/, &fetchdoc($netbsdbase."README-all.html");
		for (my $i = 10; $i < @lines; $i++) {
			if ($lines[$i] =~ /^<!-- [0-9A-Za-z]/) {
				my @parts = split / /, $lines[$i];
				($ininames[$now],$iniversions[$now]) = &combos($parts[1]);
				$now++;
				@parts = split /a href="|">/, $lines[$i];
				push @iniurls, $netbsdbase.$parts[1];
				push @inirepos, "";
				push @inisizes, "";
				push @inidates, "";
			}
		}
		open OUT, ">$file";
		for (my $i = 0; $i < @iniurls;$i++) {
			print OUT "$ininames[$i]\t$iniversions[$i]\t$iniurls[$i]\n";
		}
		close OUT;
	}
	my ($p1,$p2,$p3,$p4,$p5,$p6) = &search_by_name(\@ininames,\@iniversions,\@inisizes,\@inidates,\@inirepos,\@iniurls,$_[0]);
	my @names    = @$p1;
	my @versions = @$p2;
	my @sizes    = @$p3;
	my @dates    = @$p4;
	my @repos    = @$p5;
	my @urls     = @$p6;
	for (my $i = 0; $i < @repos; $i++) {
		&pretty_print($cols,@columns,$distroname,$names[$i],$versions[$i],$sizes[$i],$dates[$i],$repos[$i],$urls[$i]);
	}
	return ();
}

sub openbsd {
	my $rel = 3.7;
	my $baseurl = "http://www.openbsd.org/".$rel."_packages/";
	my @ininames;
	my @iniversions;
	my @iniurls;
	my @inirepos;
	my @inisizes;
	my @inidates;
	my $distroname = "OpenBSD";
	my $file = "$confdir/$distroname\_$rel.list";
	# if the list file exists and is recent, use its contents, otherwise download and parse a fresh copy
	if (-s $file && `date -Idate` =~ (split / /, `ls -l $file`)[6]) {
		open IN, $file;
		chomp (my @lines = <IN>);
		for (my $i = 0; $i<@lines;$i++) {
			($ininames[$i],$iniversions[$i],$iniurls[$i]) = split /\t/, $lines[$i];
		}
		close IN;
	} else {
		my @lines = split /\n/, &fetchdoc($baseurl."i386.html");
		my $now = 0;
		for (my $i = 0; $i < @lines; $i++) {
			if ($lines[$i] =~ /^<td><b><a/) {
				my @parts = split />|href=|\.tgz</, $lines[$i];
				push @iniurls, $baseurl.$parts[3];
				($ininames[$now],$iniversions[$now]) = &combos($parts[4]);
				$now++;
				push @inirepos, "";
				push @inisizes, "";
				push @inidates, "";
			}
		}
		open OUT, ">$file";
		for (my $i = 0; $i < @iniurls;$i++) {
			print OUT "$ininames[$i]\t$iniversions[$i]\t$iniurls[$i]\n";
		}
		close OUT;
	}
	my ($p1,$p2,$p3,$p4,$p5,$p6) = &search_by_name(\@ininames,\@iniversions,\@inisizes,\@inidates,\@inirepos,\@iniurls,$_[0]);
	my @names    = @$p1;
	my @versions = @$p2;
	my @sizes    = @$p3;
	my @dates    = @$p4;
	my @repos    = @$p5;
	my @urls     = @$p6;
	for (my $i = 0; $i < @repos; $i++) {
		&pretty_print($cols,@columns,$distroname,$names[$i],$versions[$i],$sizes[$i],$dates[$i],$repos[$i],$urls[$i]);
	}
	return ();
}

sub gentoo {
	my @names;
	my @versions;
	my @urls;
	my @dates;
	my @lines = split /\n/, &fetchdoc($gentoobase."/search/?sstring=".$_[0]);
	my $name;
	my @repos;
	my @sizes;
	for (my $i = 200; $i < @lines; $i++) { # starting value is a speed compromise
		if ($lines[$i] eq '<table class="ebuild">') {
			$name = (split /fields">|<\/td/, $lines[$i+1])[1];
		} elsif ($lines[$i] =~ /th class="releases/) {
			push @names, $name;
			my @parts = split /href="|" title="|">|<\/a/, $lines[$i];
			push @urls, $parts[2];
			$parts[3] =~ s/ ..:..:..\.00//;
			push @dates,    $parts[3];
			push @versions, $parts[4];
			push @repos, "";
			push @sizes, "";
		}
	}
	my %more_recent;
	for (my $i = 0; $i < @repos; $i++) {
		unless (defined($more_recent{$names[$i]})) {
			&pretty_print($cols,@columns,"Gentoo",$names[$i],$versions[$i],$sizes[$i],$dates[$i],$repos[$i],$urls[$i]);
			$more_recent{$names[$i]} = 1;
		}
	}
	return ();
}

sub slack {
	my $slackbase  = "http://slackware.it/en/pb";
	my @repos;
	my @names;
	my @versions;
	my @urls;
	my @combos;
	my @sizes;
	my @dates;
	my @lines = split /\n|<br>|<\/td>/, &fetchdoc($slackbase."/searchpkg.php?v=current&string=".$_[0]);
	my $repo;
	my $now = 0;
	for (my $i = 0; $i < @lines; $i++) {
		if ($lines[$i] =~ /Found [123456789][0-9]* results/) {
			chop ($repo = (split /results in |\/<br>/, $lines[$i])[1]);
		} elsif ($lines[$i] =~ /<td nowrap>\[/) {
			push @repos, $repo;
			my @parts = split /a href="|"><b>|<\/b>/, $lines[$i];
			$parts[4] =~ s/\/[a-z0-9-]+\///; # dropping some package group information here, could be used...
			($names[$now],$versions[$now]) = &combos($parts[4]);
			$now++;
			push @urls, $parts[3];
			push @dates, "";
			push @sizes, "";
		}
	}
	for (my $i = 0; $i < @repos; $i++) {
		&pretty_print($cols,@columns,"Slackware",$names[$i],$versions[$i],$sizes[$i],$dates[$i],$repos[$i],$urls[$i]);
	}
	return ();
}

sub debian {
	my @names;
	my @repos;
	my @versions;
	my @urls;
	my @sizes;
	my @dates;
	my @lines = split /\n/, &fetchdoc($debianbase."/cgi-bin/search_packages.pl?version=all&subword=1&exact=&arch=any&releases=all&case=insensitive&keywords=".$_[0]."&searchon=names");
	for (my $i = 50; $i < @lines; $i++) {
		if ($lines[$i] =~ /<h3>Package/) {
			my $name = (split /h3>Package |<\/h3>/, $lines[$i])[1];
			my $a = $i+2;
			my $have_version = 1;
			for (;$a < @lines;$a++) {
				if ($lines[$a] =~ /^<li>/) {
					my @parts = split /href="|">|<\/a/, $lines[$a];
					push @names, $name;
					push @repos, $parts[2];
					push @urls,  $debianbase.$parts[1];
					push @sizes, "";
					push @dates, "";
					$have_version = 0;
				} elsif ($lines[$a] =~ /^<br>/) {
					if ($have_version == 0) {
						my @parts = split />|:/, $lines[$a];
						push @versions, $parts[1];
					}
					$have_version = 1;
				} elsif ($lines[$a+1] =~ /<h3/) {
					last;
				}
			}
			$i = $a;
		}
	}
	for (my $i = 0; $i < @repos; $i++) {
		&pretty_print($cols,@columns,"Debian",$names[$i],$versions[$i],$sizes[$i],$dates[$i],$repos[$i],$urls[$i]);
	}
	return ();
}

sub aur {
	my $stop;
	my @lines = split /\n/, &fetchdoc($aurbase."/packages.php?PP=1000&K=".$_[0]); # 1000 should be enough

	my @repos;
	my @names;
	my @versions;
	my @combos;
	my @dates;
	my @urls;
	my @sizes;
	my @dates;
	my $indicator = 0;
	for (my $i = 100; $i < @lines; $i++) {  # 100 is a compromise between safety and efficiency
		if ($lines[$i] =~ /<td class='data/) {
			$indicator++;
			if ($indicator == 1) {
				push @repos,    &arch_site_get_cont($lines[$i]);
				push @sizes, "";
				push @dates, "";
			} elsif ($indicator == 3) {
				push @combos,    &arch_site_get_cont($lines[$i]);
				push @urls,      $aurbase.&aur_site_get_url ($lines[$i]);
			} elsif ($indicator == 6) {
				$indicator = 0;
			}
			# 2 is package group, 4 is votes, 5 is description, 6 is maintainer
		}
	}
	foreach (@combos) {
		my @units = split / /, $_;
		push @names,    $units[0];
		push @versions, $units[1];
	}
	for (my $i = 0; $i < @repos; $i++) {
		&pretty_print($cols,@columns,"Arch",$names[$i],$versions[$i],$sizes[$i],$dates[$i],$repos[$i],$urls[$i]);
	}
	return ();
}

sub arch {
	my $stop;
	my @lines = split /\n/, &fetchdoc($archbase."/packages.php?pp=1000&s_keyword=".$_[0]); # 1000 should be enough
	for (my $i = @lines - 1; $i > 0; $i--) {   # $stop was 865 when I wrote this, total file was only 903
		if ($lines[$i] eq "\t\t</tr></table>\t\t</td>") {
			$stop = $i;
			last;
		}
	}

	my @repos;
	my @names;
	my @versions;
	my @dates;
	my @urls;
	my @sizes;
	my $indicator = 0;
	for (my $i = 380; $i < $stop; $i++) {  # 380 is a compromise between safety and efficiency
		if ($lines[$i] =~ /<td class="data/) {
			$indicator++;
			if ($indicator == 1) {
				push @repos,    &arch_site_get_cont($lines[$i]);
			} elsif ($indicator == 3) {
				push @names,    &arch_site_get_cont($lines[$i]);
				push @urls,     $archbase.&arch_site_get_url ($lines[$i]);
			} elsif ($indicator == 4) {
				push @versions, &arch_site_get_cont($lines[$i]);
			} elsif ($indicator == 6) {
				push @dates,    &arch_site_get_cont($lines[$i]);
				push @sizes, "";
				$indicator = 0;
			}
			# 2 is package group, 5 is description
		}
	}
	for (my $i = 0; $i < @repos; $i++) {
		&pretty_print($cols,@columns,"Arch",$names[$i],$versions[$i],$sizes[$i],$dates[$i],$repos[$i],$urls[$i]);
	}
	return ();
}




sub arch_site_get_cont {
	my @parts = split />/, $_[0];
	for (my $i = 0; $i < @parts; $i++) {
		if ($parts[$i] =~ /^[A-Za-z0-9]/) {
			return (split /</, $parts[$i])[0];
		}
	}
}

sub arch_site_get_url {
	return ((split /a href='|'>/, $_[0])[1]);
}

sub aur_site_get_url {
	return ((split /a href='|&O=/, $_[0])[1]);
}


sub fetchdoc {
	use LWP::UserAgent;

	my $url = $_[0];
	my $silent = 0;
	if (@_ == 2 && $_[1] eq "silent") {
		$silent = 1;
	}

	$url =~ s/\&amp\;/\&/ig;   # convert &amp; to &

	my $ua = LWP::UserAgent->new;
        my @firstline;
        my @response;
        for (my $count = 0; ; ++$count) {   # termination condition inside loop
                my $req = HTTP::Request->new(GET => $url);
                my $res = $ua->request($req)->as_string;
                @response = split (/\n/, $res);
                @firstline = split (/ /, $response[0]);
		my $restest = 0;
		if (@firstline == 3) {
			$restest = $firstline[1];
		} elsif (@firstline > 3) {
			$restest = $firstline[0];
		}
		if ($restest == 200 || $response[0] =~ /200 OK/) { #NB the matching expression added specifically for NetBSD package page!
		# server response 200 is a stringent criterion, but should work
			last;
		} elsif ($count > 4) {   # loop termination condition
			unless ($silent == 1) {
				print ("Tried fetching \"$url\" five times for $_[1]. Giving up.\n");
			}
			return ();
			last;
		}
	}
        my $end = @response - 1;
        my $finaldoc = join ("\n", @response[14..$end]);
        return ($finaldoc);
}

sub pretty_print {
	my $n = $_[0];
	my @colwidths = @_[1..$n];
	my @colvals = @_[($n+1)..(@_-1)];
	for (my $i = 0; $i < @colwidths;$i++) {
		if (length($colvals[$i]) > $colwidths[$i]) {
			my @letters = split //, $colvals[$i];
			print join "", @letters[0..($colwidths[$i]-1)];
			print " ";
		} else {
			print $colvals[$i];
			for (my $a = 0; $a < $colwidths[$i] + 1 - length($colvals[$i]); $a++) {
				print " ";
			}
		}
	}
	print $colvals[@colvals-1]."\n"; #last column is unrestricted in length
}


sub template_query {
	my $query = "url";
	my @lines = split /\n/, &fetchdoc($query);
	my @names;
	my @versions;
	my @dates;
	my @sizes;
	my @repos;
	my @urls;
	my $now = 0;
	for (my $i = 0; $i<@lines; $i++) {
		if ($lines[$i] =~ /unique_tag/) {
			# typically, this is where most of the text processing goes:
			# getting the info and putting it in appropriate arrays

			# use subroutine "combos" if the name and version are represented as, firefox-1.0.6, with the hyphen, and the version number starting with a digit
			my $anchor = "something";
			($names[$now],$versions[$now]) = &combos($anchor);
			$now++;
			push @names,    "";
			push @versions, "";
			push @repos,    "";
			push @sizes,    "";
			push @urls,     "";
			push @dates,    "";
		}
	}
	for (my $i = 0; $i < @repos; $i++) {
		&pretty_print($cols,@columns,"Distroname",$names[$i],$versions[$i],$sizes[$i],$dates[$i],$repos[$i],$urls[$i]);
	}
	return ();
}

sub template_listing {
	my @ininames;
	my @iniversions;
	my @iniurls;
	my @inirepos;
	my @inisizes;
	my @inidates;
	my $now = 0;
	my $distroname = "mydistro";
	# prepare a list file
	my $file = "$confdir/$distroname.list";
	# if the list file exists and is recent, use its contents, otherwise download and parse a fresh copy
	if (-s $file && `date -Idate` =~ (split / /, `ls -l $file`)[6]) {
		open IN, $file;
		chomp (my @lines = <IN>);
		for (my $i = 0; $i<@lines;$i++) {
			# get back any info that you put in the file
			($ininames[$i],$iniversions[$i],$iniurls[$i]) = split /\t/, $lines[$i];
		}
		close IN;
	} else {
		# download fresh copy
		my @lines = split /\n/, &fetchdoc($netbsdbase."README-all.html");
		for (my $i = 0; $i < @lines; $i++) {
			if ($lines[$i] =~ /unique_tag/) {
				# extract all info from the downloaded list
				my @parts = split / /, $lines[$i];
				# use subroutine "combos" to separate name and version number
				($ininames[$now],$iniversions[$now]) = &combos($parts[1]);
				$now++;
				# any info you couldn't get, put a blank in
				push @iniurls,  "";
				push @inirepos, "";
				push @inisizes, "";
				push @inidates, "";
			}
		}
		open OUT, ">$file";
		for (my $i = 0; $i < @iniurls;$i++) {
			# store the available info in the file
			print OUT "$ininames[$i]\t$iniversions[$i]\t$iniurls[$i]\n";
		}
		close OUT;
	}
	# search by hand
	my ($p1,$p2,$p3,$p4,$p5,$p6) = &search_by_name(\@ininames,\@iniversions,\@inisizes,\@inidates,\@inirepos,\@iniurls,$_[0]);
	my @names    = @$p1;
	my @versions = @$p2;
	my @sizes    = @$p3;
	my @dates    = @$p4;
	my @repos    = @$p5;
	my @urls     = @$p6;
	for (my $i = 0; $i < @repos; $i++) {
		&pretty_print($cols,@columns,$distroname,$names[$i],$versions[$i],$sizes[$i],$dates[$i],$repos[$i],$urls[$i]);
	}
	return ();
}



